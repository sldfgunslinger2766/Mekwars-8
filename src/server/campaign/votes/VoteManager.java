package server.campaign.votes;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Iterator;
import server.campaign.SHouse;
import server.campaign.SPlayer;
import server.campaign.CampaignMain;


/**
 * 
 * @author urgru 8/18/04
 *
 * The VoteManager controls all vote casting and counting for a campaign.
 * 
 * Current implementation uses phenomenally inefficient vector sorting
 * and doesnt save its contents. At some point, McWizard will change this
 * to use Hibernate and make it not suck. =)
 * 
 * Houses and players use the VoteManager to get access to information they
 * need. Lists of outstanding votes, player vote totals, etc. So long as these
 * calls are duplicated when the VM is Hibernated, and return vote vectors, nothing
 * in SHouse or SPlayer should be broken by the transition.
 */
@SuppressWarnings({"unchecked","serial"})
public class VoteManager {
	
	//ivars
	Vector voteVector;
	CampaignMain cm;
	
	//constructor
	public VoteManager(CampaignMain campmain) {
		voteVector = new Vector(1,1);
		cm = campmain;
	}
	
	/**
	 * 
	 * @param v vote to check
	 * 
	 * Check to see if a vote has an equivalent (same 
	 * caster and recipient already in the collection).
	 * 
	 * Generally speaking, players are only be allowed
	 * to vote once for any other player -- positive,
	 * negative or otherwise. So no need to check the type.
	 */
	public boolean checkForDuplicate(Vote v) {
		
		Enumeration e = voteVector.elements();
		Vote nextVote = null;
		boolean dupeFound = false;//has a duplicate been found?
		
		//loop through all the elements; however if a
		//dupe has already been found, no need to continue
		while (e.hasMoreElements() && !dupeFound) {
			//get next element and reset booleans
			nextVote = (Vote)e.nextElement();
			
			if (nextVote.isEqualTo(v, false)) {
				dupeFound = true;
			}
		}//end while(more elements)
		
		//return if vote duplicates the caster and
		//recipient of an existing vote
		return dupeFound;
	}//end checkForDuplicate
	
	/**
	 * 
	 * @param v a vote w/ caster and recipient
	 * @return boolean indivating whether caster and recip are in same faction
	 * 
	 * quick check to make sure player casting vote and player receiving vote are
	 * in the same faction.
	 */
	public boolean checkForHouseMatch(Vote v) {
		boolean toReturn = false;
		
		SHouse casterHouse = cm.getHouseForPlayer(v.getCaster());
		SHouse recipientHouse = cm.getHouseForPlayer(v.getRecipient());
		
		if (casterHouse.equals(recipientHouse)) {
			toReturn = true;
		}
		
		return toReturn;
	}//end checkForHouseMatch()
	
	
	/**
	 * 
	 * @param v the vote to add
	 * @return boolean true if vote was added succesfully
	 * 
	 * Takes a vote object and appends it to the voteVector.
	 * Votes should only generated by VoteCommand.java
	 * 
	 * Don't add duplicate votes.
	 * Don't add votes outside of a faction.
	 */
	public boolean addVote(Vote v) {
		boolean isDuplicate = this.checkForDuplicate(v);
		boolean playersInSameHouse = this.checkForHouseMatch(v);
		
		//This check shouldnt ever fail, since its run in the VoteCommand
		//as well. If it does, something is very very wrong.
		if (isDuplicate || !playersInSameHouse) {
			return false;
		}
		
		//else
		voteVector.add(v);
		return true;
	}//end addVote
	
	/**
	 * 
	 * @param v vote to try and remove
	 * @return boolean true if vote was removed
	 * 
	 * Run through an iterator, comparing a newly generated vote
	 * to the Managed votes. If A vote like the new vote exists,
	 * remove it from the vote vector.
	 */
	public boolean removeVote(Vote v) {
		Iterator i = voteVector.iterator();
		boolean voteRemoved = false;
		
		//look while elements remain, but stop once there
		//has been a removal.
		while (i.hasNext() && !voteRemoved) {
			Vote nextVote = (Vote)i.next();
			if (nextVote.isEqualTo(v, true)) {
				i.remove();//remove the vote from the voteVector
				voteRemoved = true;//change the return value
			}
		}//end while(more elements in iterator)
		
		return voteRemoved;
	}//end removeVote
	
	/**
	 * 
	 * Loop through and grab all votes for
	 * a given player (eg - all votes for "urgru")
	 * 
	 * @param p player
	 * @return a vector of votes
	 */
	public Vector getAllVotesFor(SPlayer p) {
		Vector toReturn = new Vector(1,1);
		
		//loop and get the votes
		Enumeration e = voteVector.elements();
		while (e.hasMoreElements()) {
			Vote v  = (Vote)e.nextElement();
			if (p.getName().equals(v.getRecipient())) {
				toReturn.add(v);
			}
		}///end while(more elements)
		return toReturn;
	}//end getAllVotesFor()
	
	/**
	 * 
	 * @param p player
	 * @param type vote type to look for
	 * @return Vector of votes
	 * 
	 * Takes results of getAllVotesFor(Player) and filters by vote type.
	 */
	public Vector getAllVotesFor(SPlayer p, int type) {
		Vector votesForPlayer = this.getAllVotesFor(p);
		Vector toReturn = new Vector(1,1);
		Enumeration e = votesForPlayer.elements();
		while (e.hasMoreElements()) {
			Vote currVote = (Vote)e.nextElement();
			if (currVote.getType() == type) {
				toReturn.add(currVote);
			}//end if(types match)
		}//end while (more elements)
		return toReturn;
	}//end getAllVotesFor
	
	/**
	 * 
	 * Loop through and grab all votes of cast by
	 * a given player (eg - all votes cast by "McWizard")
	 * 
	 * @param p player
	 * @return a vector of votes
	 */
	public Vector getAllVotesBy(SPlayer p) {
		Vector toReturn = new Vector(1,1);
		
		//loop and get the votes
		Enumeration e = voteVector.elements();
		while (e.hasMoreElements()) {
			Vote v  = (Vote)e.nextElement();
			if (p.getName().equals(v.getCaster())) {
				toReturn.add(v);
			}
		}///end while(more elements)
		return toReturn;
	}//end getAllVotesFor()
	
	/**
	 * 
	 * @param p player
	 * @param type vote type to look for
	 * @return Vector of votes
	 * 
	 * Takes results of getAllVotesBy(Player) and filters by vote type.
	 */
	public Vector getAllVotesBy(SPlayer p, int type) {
		Vector votesByPlayer = this.getAllVotesBy(p);
		Vector toReturn = new Vector(1,1);
		Enumeration e = votesByPlayer.elements();
		while (e.hasMoreElements()) {
			Vote currVote = (Vote)e.nextElement();
			if (currVote.getType() == type) {
				toReturn.add(currVote);
			}//end if(types match)
		}//end while (more elements)
		return toReturn;
	}//end getAllVotesFor
	
	/**
	 * 
	 * @param p player for whom votes should be removed
	 * 
	 * Removes all votes for a player. alled by Sfaction when
	 * a player is removed.
	 */
	public void removeAllVotesForPlayer(SPlayer p) {
		Vector votesForPlayer = this.getAllVotesFor(p);
		Enumeration e = votesForPlayer.elements();
		while (e.hasMoreElements()) {
			//make a dummy vote with the 
			Vote currVote = (Vote)e.nextElement();
			this.removeVote(currVote);
		}//end while(votes remain to be removed)
	}//end removeAllVotesForPlayer()
	
	/**
	 * 
	 * @param p player whose votes should be removed
	 * 
	 * Removes all votes cast by a player. Called by Sfaction
	 * when a player is removed.
	 */
	public void removeAllVotesByPlayer(SPlayer p) {
		Vector votesByPlayer = this.getAllVotesBy(p);
		Enumeration e = votesByPlayer.elements();
		while (e.hasMoreElements()) {
			Vote currVote = (Vote)e.nextElement();
			this.removeVote(currVote);
		}//end while(votes remain to be removed)
	}//end removeAllVotesByPlayer()
	
	/**
	 * 
	 * @param h House to search
	 * @return Vector of votes cast by players of House h
	 * 
	 * Queries all votes, collects votes cast by players of the
	 * given faction, and returns a vector.
	 */
	public Vector getAllHouseVotes(SHouse h) {
		Vector toReturn = new Vector(1,1);
		Enumeration e = voteVector.elements();
		while (e.hasMoreElements()) {
			//can assume votes are all for people in the same faction,
			//or they would not have passed add
			Vote v = (Vote)e.nextElement();
			SHouse casterHouse = cm.getHouseForPlayer(v.getCaster());
			if (h.equals(casterHouse)) {
				toReturn.add(v);
			}//end if(matching faction)
		}//end while(more elements)
		return toReturn;
	}//end getAllHouseVotes(House)
	
	/**
	 * 
	 * @param h House to search
	 * @param type Type of vote to isolate
	 * @return Vector of votes
	 */
	public Vector getAllHouseVotes(SHouse h, int type) {
		Vector factionVotes = this.getAllHouseVotes(h);
		Vector toReturn = new Vector(1,1);
		Enumeration e = factionVotes.elements();
		while (e.hasMoreElements()) {
			Vote currVote = (Vote)e.nextElement();
			if (currVote.getType() == type) {
				toReturn.add(currVote);
			}//end if(types match)
		}//end while(more elements)
		return toReturn;
	}//end getAllHouseVotes(faction, type)
	
}//end VoteManager class